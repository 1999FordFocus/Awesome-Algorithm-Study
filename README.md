# Awesome-Algorithm-Study

从零构建算法核心知识地图，打通你的任督二脉~

<div align="center">
<img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Performance/master/screenshots/algorithm_map.png">
</div>


## 什么是算法面试？

- 1、不代表能够"正确"回答每一个算法问题，但是合理的思考方向其实更重要，也是正确完成算法面试的前提。
- 2、算法面试优秀并不意味着技术面试优秀，而技术面试优秀也并不意味着能够拿到 Offer。
- 3、把面试的过程看作是和面试官一起探讨一个问题的解决方案。对于问题的细节和应用场景，可以和面试官沟通。而这种沟通本身也是非常重要的，它暗示着你思考问题的方式。
- 4、如果是非常难的问题，对于你的竞争对手来说，也是难的。关键在于你所表达出的解决问题的思路。甚至通过表达解题思路的方向，得出结论：这个问题的解决方案，应该在哪一个领域，我们可以通过查阅或者进一步学习解决问题。例如：对于一组数据进行排序？思考：这组数据有什么特征？
     - 1）、有没有可能包含有大量重复元素？如果有这种可能的话，三路快排是更好的选择。否则使用普通快排即可。
     - 2）、是否大部分数据距离它正确的位置很近？是否近乎有序？如果是这样的话，插入排序是更好的选择。
     - 3）、是否数据的取值范围非常有限？比如对学生成绩排序，如果是这样的话，计数排序是更好的选择。
     - 4）、是否需要稳定的排序？如果是的话，归并排序是更好地选择。
     - 5）、是否是使用链表存储的？如果是的话，归并排序是更好地选择，因为快排非常依赖于数组的随机访问。
     - 6）、数据的大小是否可以装载到内存里？不能的话，需要使用外排序。


## 如何准备算法面试？

在学习和实践做题之间，要掌握平衡。


## 如何回答算法面试问题？

### 1、注意题目中的条件，例如

- 1）、给定一个有序的数组。
- 2）、设计一个 O(nlogn) 的算法。
- 3）、无需考虑额外的空间。
- 4）、数据规模大概是10000。


### 2、当没有思路时

- 1）、设计几个简单的测试用例，试验一下。
- 2）、不要忽视暴力解法。暴力解法通常是思考的起点。


### 3、优化算法

- 1）、遍历常见的算法思路。
- 2）、遍历常见的数据结构。
- 3）、空间和时间的交互（哈希表）。


### 4、预处理信息（排序）


### 5、在瓶颈处寻找答案：O(nlogn) + O(n^2)、O(n^3)


### 6、实际编写问题

- 1）、极端条件的判断：数组为空？字符串为空？数量为0？指针为 NULL？
- 2）、合理的变量名。
- 3）、注意代码的模块化、复用性。


## 时间复杂度

### 1、到底什么是大 O？

n 表示数据规模，O(f(n)) 表示运行算法所需要执行的指令数，和 f(n) 成正比。
     
     
### 2、数据规模的概念——如果想在1s之内解决问题

- 1）、O(n^2) 的算法可以处理大约10^4级别的数据。
- 2）、O(n) 的算法可以处理大约10^8级别的数据。
- 3）、O(nlogn) 的算法可以处理大约10^7级别的数据。


### 3、空间复杂度

- 1）、多开一个辅助的数组：O(n)。
- 2）、多开一个辅助的二维数组：O(n^2)。
- 3）、多开常数空间：O(1)。
- 4）、递归是有空间代价的，递归 n 次，空间复杂度就为 O(n)。


### 4、简单的时间复杂度分析

#### 为什么要用大O，叫做大O(n)？

忽略了常数，实际时间 T = c1 * n + c2。

#### 为甚不加上其中每一个常数项，而是要忽略它？

比如说把一个数组中的元素取出来这个操作，很有可能不同的语音基于不同的实现，它实际运行的时间是不等的。
就算转换成机器码，它对应的那个机器码的指令数也有可能是不同的。就算指令数是相同的，同样一个指令在 CPU
的底层，你使用的 CPU 不同，很有可能执行的操作也是不同的。所以，在实际上我们大概能说出来这个 c1
是多少，但是很难准确判断其具体的值。

大O的表示的是渐进时间复杂度，当 n 趋近于无穷大的时候，其算法谁快谁慢。


### 5、亲自试验自己算法的时间复杂度

O(log(n)) 与 O(n) 有着本质的差别。


### 6、递归算法的复杂度分析

- 1）、不是有递归的函数就是一定是 O(nlogn) 的。
- 2）、递归中进行一次递归调用：递归函数的时间复杂度为 O(T * depth)。
- 3）、递归中进行多次递归调用：画出递归树，计算调用次数。例如2次递归调用：2^0 + ... 2^n = 2^(n+1) - 1 = O(2^n)
- 4）、主定理：归纳了递归函数所计算时间复杂度的所有情况。


### 7、均摊时间复杂度分析（Amortized Time Analysis）与 避免复杂度的震荡
    
#### 均摊时间复杂度分析

假设 capacity = n，n + 1 次 addLast/removeLast，触发 resize，总共进行 2n + 1 次基本操作平均来看，每次 addLast/removeLast 操作，进行 2 次基本操作均摊计算，时间复杂度为 O（1）。

#### 复杂度震荡
          
当反复先后调用 addLast/removeLast 进行操作时，会不断地进行 扩容/缩容，此时时间复杂度为 O（n）出现问题的原因：removeLast 时 resize 过于着急。
解决方案：Lazy （在这里是 Lazy 缩容）等到 size == capacity / 4 时，才将 capacity 减半。
 

## 目录

### [算法基础]()（已完成，待记录）

- **《漫画算法》 （已完成，待记录）**


### [剑指Offer题解]()（已完成，待记录）

- **《剑指Offer》（已完成，待记录）**


### [Lettcode高频题解]()（进行中~）

- **LetteCode（进行中~）**

- **拉钩教育之《300分钟搞定数据结构和算法》（已完成）**
-  **慕课网之[玩转算法面试，从真题到思维全面提升算法思维](https://coding.imooc.com/learn/list/82.html)三门课程视频、看得见的算法（已完成）**
-  **极客时间之《算法面试通关》（已完成）**



## 赞赏

如果这个库对您有很大帮助，您愿意支持这个项目的进一步开发和这个项目的持续维护。你可以扫描下面的二维码，让我喝一杯咖啡或啤酒。非常感谢您的捐赠。谢谢！

<div align="center">
<img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/wexin_play.jpg" width=20%><img src="https://raw.githubusercontent.com/JsonChao/Awesome-Android-Interview/master/screenshot/Apaliy.jpg" width=20%>
</div>


----

## Contanct Me

###  ●  微信：

> 欢迎关注我的微信：`bcce5360`  

###  ●  微信群：

> **微信群如果不能扫码加入，麻烦大家想进微信群的朋友们，加我微信拉你进群。**

<div align="center">
<img src="https://github.com/JsonChao/Awesome-Android-Performance/blob/master/screenshots/Awesome-Android.png" width=35%>
</div>
        

###  ●  QQ群：

> 2千人QQ群，**Awesome-Android学习交流群，QQ群号：959936182**， 欢迎大家加入~


### About me

- #### Email:[chao.qu521@gmail.com]()
- #### Blog:[https://jsonchao.github.io/](https://jsonchao.github.io/)
- #### 掘金:[https://juejin.im/user/5a3ba9375188252bca050ade](https://juejin.im/user/5a3ba9375188252bca050ade)

